{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/djikstra.js","algorithms/AStar.js","algorithms/DFS.js","algorithms/BFS.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","djikstra","grid","startNode","finishNode","openList","distance","closedList","nodes","node","push","getDistanceArray","length","sort","nodeA","nodeB","shift","Infinity","isVisited","relaxTheNodes","unvisitedNeighbors","neighbors","filter","neighbor","toBeVisited","previousNode","AStar","heuristic","PathfindingVisualizer","setUpTheGrid","rowCount","colCount","initialGrid","currentRow","setUpTheNodes","state","startRow","startCol","finishRow","finishCol","Math","abs","isNode","mouseIsPressed","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","desktop","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","setState","clearGrid","clearWalls","isGridClear","document","getElementById","newGrid","toggleWalls","nodeClassName","startCoL","slice","algo","q","BFS","stack","splice","DFS","pathToTarget","curr","unshift","getThePathToTheTarget","animate","DELAY","i","setTimeout","animatePathToTheTarget","type","onClick","visualize","onMouseLeave","map","rowId","nodeId","handleMouseEnter","handleMouseUp","changeView","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"mTAIqBA,E,4JACnB,WACE,MASIC,KAAKC,MARPC,EADF,EACEA,IACAC,EAFF,EAEEA,SACAC,EAHF,EAGEA,QACAC,EAJF,EAIEA,OACAC,EALF,EAKEA,YACAC,EANF,EAMEA,aACAC,EAPF,EAOEA,UACAC,EARF,EAQEA,IAEIC,EAAiBP,EACnB,cACAC,EACA,aACAC,EACA,YACA,GAEJ,OACE,qBACEM,GAAE,eAAUF,EAAV,YAAiBP,GACnBU,UAAS,eAAUF,GACnBJ,YAAa,kBAAMA,EAAYG,EAAKP,IACpCK,aAAc,kBAAMA,EAAaE,EAAKP,IACtCM,UAAW,kBAAMA,W,GA1BSK,aCI3B,SAASC,EAASC,EAAMC,EAAWC,GACtC,IAAMC,EAAW,GACjBF,EAAUG,SAAW,EAKrB,IAFA,IAAMC,EAiBR,SAA0BL,GACxB,IAD8B,EACxBM,EAAQ,GADgB,cAEZN,GAFY,IAE9B,2BAAwB,CAAC,IAAD,EAAbN,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAda,EAAa,QACtBD,EAAME,KAAKD,IAFS,gCAFM,8BAO9B,OAAOD,EAxBYG,CAAiBT,GAE7BK,EAAWK,QAAQ,CACxBL,EAAWM,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMR,SAAWS,EAAMT,YACzD,IAAMG,EAAOF,EAAWS,QAKtB,GAAIP,EAAKH,WAAaW,IAAU,OAAOZ,EAGvC,GAFAI,EAAKS,WAAY,EACjBb,EAASK,KAAKD,GACVA,IAASL,EAAY,OAAOC,EAChCc,EAAcV,EAAMP,IAc1B,SAASiB,EAAcV,EAAMP,GAG3B,IAHiC,EAG3BkB,EAOR,SAAqBX,EAAMP,GACzB,IAAMmB,EAAY,GACXhC,EAAYoB,EAAZpB,IAAKO,EAAOa,EAAPb,IACRA,EAAM,GAAGyB,EAAUX,KAAKR,EAAKN,EAAM,GAAGP,IACtCO,EAAMM,EAAKU,OAAS,GAAGS,EAAUX,KAAKR,EAAKN,EAAM,GAAGP,IACpDA,EAAM,GAAGgC,EAAUX,KAAKR,EAAKN,GAAKP,EAAM,IACxCA,EAAMa,EAAK,GAAGU,OAAS,GAAGS,EAAUX,KAAKR,EAAKN,GAAKP,EAAM,IAG7D,OAAOgC,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAASL,YAAcK,EAAS/B,UAhB1CgC,CAAYf,EAAMP,GAHZ,cAIVkB,GAJU,IAIjC,2BAA2C,CAAC,IAAjCG,EAAgC,QACzCA,EAASjB,SAAWG,EAAKH,SAAW,EACpCiB,EAASE,aAAehB,GANO,+BC3B9B,SAASiB,EAAMxB,EAAMC,EAAWC,GACnC,IAAMC,EAAW,GACjBF,EAAUG,SAAW,EAKrB,IAFA,IAAMC,EAiBR,SAA0BL,GACxB,IAD8B,EACxBM,EAAQ,GADgB,cAEZN,GAFY,IAE9B,2BAAwB,CAAC,IAAD,EAAbN,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAda,EAAa,QACtBD,EAAME,KAAKD,IAFS,gCAFM,8BAO9B,OAAOD,EAxBYG,CAAiBT,GAE7BK,EAAWK,QAAQ,CACxBL,EAAWM,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMR,SAAWS,EAAMT,YACzD,IAAMG,EAAOF,EAAWS,QAKtB,GAAIP,EAAKH,WAAaW,IAAU,OAAOZ,EAGvC,GAFAI,EAAKS,WAAY,EACjBb,EAASK,KAAKD,GACVA,IAASL,EAAY,OAAOC,EAChCc,EAAcV,EAAMP,IAc1B,SAASiB,EAAcV,EAAMP,GAC3B,IADiC,EAC3BkB,EAOR,SAAqBX,EAAMP,GAGzB,IAAMmB,EAAY,GACXhC,EAAYoB,EAAZpB,IAAKO,EAAOa,EAAPb,IACRA,EAAM,GAAGyB,EAAUX,KAAKR,EAAKN,EAAM,GAAGP,IACtCO,EAAMM,EAAKU,OAAS,GAAGS,EAAUX,KAAKR,EAAKN,EAAM,GAAGP,IACpDA,EAAM,GAAGgC,EAAUX,KAAKR,EAAKN,GAAKP,EAAM,IACxCA,EAAMa,EAAK,GAAGU,OAAS,GAAGS,EAAUX,KAAKR,EAAKN,GAAKP,EAAM,IAG7D,OAAOgC,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAASL,YAAcK,EAAS/B,UAlB1CgC,CAAYf,EAAMP,GADZ,cAEVkB,GAFU,IAEjC,2BAA2C,CAAC,IAAjCG,EAAgC,QACzCA,EAASjB,SAAWG,EAAKH,SAAW,EAAIiB,EAASI,UACjDJ,EAASE,aAAehB,GAJO,+BClBrC,SAASe,EAAYf,EAAMP,GAGvB,IAAMmB,EAAY,GACXzB,EAAYa,EAAZb,IAAKP,EAAOoB,EAAPpB,IAOZ,OANIO,EAAM,GAAGyB,EAAUX,KAAKR,EAAKN,EAAM,GAAGP,IACtCO,EAAMM,EAAKU,OAAS,GAAGS,EAAUX,KAAKR,EAAKN,EAAM,GAAGP,IACpDA,EAAM,GAAGgC,EAAUX,KAAKR,EAAKN,GAAKP,EAAM,IACxCA,EAAMa,EAAK,GAAGU,OAAS,GAAGS,EAAUX,KAAKR,EAAKN,GAAKP,EAAM,IAGtDgC,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAASL,YAAcK,EAAS/B,UCVzE,SAASgC,EAAYf,EAAMP,GACzB,IAAMmB,EAAY,GACXhC,EAAYoB,EAAZpB,IAAKO,EAAOa,EAAPb,IAOZ,OANIA,EAAM,GAAGyB,EAAUX,KAAKR,EAAKN,EAAM,GAAGP,IACtCO,EAAMM,EAAKU,OAAS,GAAGS,EAAUX,KAAKR,EAAKN,EAAM,GAAGP,IACpDA,EAAM,GAAGgC,EAAUX,KAAKR,EAAKN,GAAKP,EAAM,IACxCA,EAAMa,EAAK,GAAGU,OAAS,GAAGS,EAAUX,KAAKR,EAAKN,GAAKP,EAAM,IAGtDgC,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAASL,YAAcK,EAAS/B,U,UCpBlDoC,E,kDACnB,aAAe,IAAD,8BACZ,gBA2DFC,aAAe,WAEb,IAFgD,IAAlCC,EAAiC,uDAAtB,GAAIC,EAAkB,uDAAP,GAClCC,EAAc,GACXpC,EAAM,EAAGA,EAAMkC,EAAUlC,IAAO,CAEvC,IADA,IAAMqC,EAAa,GACV5C,EAAM,EAAGA,EAAM0C,EAAU1C,IAChC4C,EAAWvB,KAAK,EAAKwB,cAActC,EAAKP,IAE1C2C,EAAYtB,KAAKuB,GAEnB,OAAOD,GArEK,EAwEdE,cAAgB,SAACtC,EAAKP,GACpB,MAAO,CACLO,MACAP,MACAE,QAASK,IAAQ,EAAKuC,MAAMC,UAAY/C,IAAQ,EAAK8C,MAAME,SAC3D/C,SAAUM,IAAQ,EAAKuC,MAAMG,WAAajD,IAAQ,EAAK8C,MAAMI,UAE7DjC,SAAUW,IAMVU,UAAWa,KAAKC,IAAI,EAAKN,MAAMG,UAAY1C,GAAO4C,KAAKC,IAAI,EAAKN,MAAMI,UAAYlD,GAClF6B,WAAW,EACX1B,QAAQ,EACRiC,aAAc,KACdiB,QAAQ,IAvFV,EAAKP,MAAQ,CACXjC,KAAM,GACNkC,SAAU,EACVE,UAAW,EACXD,SAAU,EACVE,UAAW,GACXI,gBAAgB,EAChBC,WAAW,EACXC,aAAa,EACbC,cAAc,EACdC,YAAY,EACZC,QAAS,EACTC,QAAS,EACTC,SAAS,GAGX,EAAKC,gBAAkB,EAAKA,gBAAgBC,KAArB,gBACvB,EAAKC,iBAAmB,EAAKA,iBAAiBD,KAAtB,gBACxB,EAAKE,gBAAkB,EAAKA,gBAAgBF,KAArB,gBApBX,E,qDAuBd,WACE,IAAMlD,EAAOf,KAAK0C,eAClB1C,KAAKoE,SAAS,CAACrD,W,6BAGjB,WACEf,KAAKoE,SAAS,CAACX,WAAYzD,KAAKgD,MAAMS,c,wBAIxC,WACE,IAAKzD,KAAKgD,MAAMS,UAAW,CACzBzD,KAAKqE,YACLrE,KAAKsE,aACL,IACIvD,EADEgD,GAAW/D,KAAKgD,MAAMe,QAExBA,GACFhD,EAAOf,KAAK0C,aAAa,GAAI,IAC7B1C,KAAKoE,SAAS,CAACL,UAAShD,YAKpBf,KAAKgD,MAAMC,SAAW,IAAMjD,KAAKgD,MAAMG,UAAY,IAAMnD,KAAKgD,MAAME,SAAW,IAAMlD,KAAKgD,MAAMI,UAAY,MAE9GpD,KAAKgD,MAAME,SAAW,EACtBlD,KAAKgD,MAAMC,SAAW,EACtBjD,KAAKgD,MAAMI,UAAY,EACvBpD,KAAKgD,MAAMG,UAAY,GAEvBpC,EAAOf,KAAK0C,aAAa,GAAI,IAC7B1C,KAAKoE,SAAS,CAACL,UAAShD,a,6BAuChC,SAAgBN,EAAKP,GACnB,IAAKF,KAAKgD,MAAMS,UACd,GAAIzD,KAAKuE,cACP,GAEE,oBADAC,SAASC,eAAT,eAAgChE,EAAhC,YAAuCP,IAAOU,UAG9CZ,KAAKoE,SAAS,CACZZ,gBAAgB,EAChBE,aAAa,EACbG,QAASpD,EACTqD,QAAS5D,SAEN,GAEL,qBADAsE,SAASC,eAAT,eAAgChE,EAAhC,YAAuCP,IAAOU,UAG9CZ,KAAKoE,SAAS,CACZZ,gBAAgB,EAChBG,cAAc,EACdE,QAASpD,EACTqD,QAAS5D,QAEN,CACL,IAAMwE,EAAUC,EAAY3E,KAAKgD,MAAMjC,KAAMN,EAAKP,GAClDF,KAAKoE,SAAS,CACZrD,KAAM2D,EACNlB,gBAAgB,EAChBI,YAAY,EACZC,QAASpD,EACTqD,QAAS5D,SAKbF,KAAKqE,c,yBAKX,WAAe,IAAD,gBACMrE,KAAKgD,MAAMjC,MADjB,IACZ,2BAAmC,CAAC,IAAD,EAAxBN,EAAwB,sBACdA,GADc,IACjC,2BAAwB,CAAC,IAAda,EAAa,QAChBsD,EAAgBJ,SAASC,eAAT,eACZnD,EAAKb,IADO,YACAa,EAAKpB,MACzBU,UACF,GACoB,sBAAlBgE,GACkB,4BAAlBA,EAEA,OAAO,GATsB,gCADvB,8BAcZ,OAAO,I,8BAGT,SAAiBnE,EAAKP,GACpB,IAAKF,KAAKgD,MAAMS,WACVzD,KAAKgD,MAAMQ,eAAgB,CAC7B,IAAMoB,EAAgBJ,SAASC,eAAT,eAAgChE,EAAhC,YAAuCP,IAC1DU,UACH,GAAIZ,KAAKgD,MAAMU,YAAa,CAC1B,GAAsB,mBAAlBkB,EACoB5E,KAAKgD,MAAMjC,KAAKf,KAAKgD,MAAMa,SAC/C7D,KAAKgD,MAAMc,SAEC1D,SAAU,EACxBoE,SAASC,eAAT,eACUzE,KAAKgD,MAAMa,QADrB,YACgC7D,KAAKgD,MAAMc,UACzClD,UAAY,OAEdZ,KAAKoE,SAAS,CAACP,QAASpD,EAAKqD,QAAS5D,IAChBF,KAAKgD,MAAMjC,KAAKN,GAAKP,GAC7BE,SAAU,EACxBoE,SAASC,eAAT,eAAgChE,EAAhC,YAAuCP,IAAOU,UAC5C,kBAEJZ,KAAKoE,SAAS,CAACnB,SAAUxC,EAAKyC,SAAUhD,SACnC,GAAIF,KAAKgD,MAAMW,aAAc,CAClC,GAAsB,mBAAlBiB,EACqB5E,KAAKgD,MAAMjC,KAAKf,KAAKgD,MAAMa,SAChD7D,KAAKgD,MAAMc,SAEE3D,UAAW,EAC1BqE,SAASC,eAAT,eACUzE,KAAKgD,MAAMa,QADrB,YACgC7D,KAAKgD,MAAMc,UACzClD,UAAY,OAEdZ,KAAKoE,SAAS,CAACP,QAASpD,EAAKqD,QAAS5D,IACfF,KAAKgD,MAAMjC,KAAKN,GAAKP,GAC7BC,UAAW,EAC1BqE,SAASC,eAAT,eAAgChE,EAAhC,YAAuCP,IAAOU,UAC5C,mBAEJZ,KAAKoE,SAAS,CAACjB,UAAW1C,EAAK2C,UAAWlD,SACrC,GAAIF,KAAKgD,MAAMY,WAAY,CAChC,IAAMc,EAAUC,EAAY3E,KAAKgD,MAAMjC,KAAMN,EAAKP,GAClDF,KAAKoE,SAAS,CAACrD,KAAM2D,Q,2BAM7B,SAAcjE,EAAKP,GACjB,IAAKF,KAAKgD,MAAMS,UAAW,CAEzB,GADAzD,KAAKoE,SAAS,CAACZ,gBAAgB,IAC3BxD,KAAKgD,MAAMU,YAAa,CAC1B,IAAMA,GAAe1D,KAAKgD,MAAMU,YAChC1D,KAAKoE,SAAS,CAACV,cAAaT,SAAUxC,EAAKoE,SAAU3E,SAChD,GAAIF,KAAKgD,MAAMW,aAAc,CAClC,IAAMA,GAAgB3D,KAAKgD,MAAMW,aACjC3D,KAAKoE,SAAS,CACZT,eACAR,UAAW1C,EACX2C,UAAWlD,IAGfF,KAAK0C,kB,8BAIT,WACE,GAAI1C,KAAKgD,MAAMU,YAAa,CAC1B,IAAMA,GAAe1D,KAAKgD,MAAMU,YAChC1D,KAAKoE,SAAS,CAACV,cAAaF,gBAAgB,SACvC,GAAIxD,KAAKgD,MAAMW,aAAc,CAClC,IAAMA,GAAgB3D,KAAKgD,MAAMW,aACjC3D,KAAKoE,SAAS,CAACT,eAAcH,gBAAgB,SACxC,GAAIxD,KAAKgD,MAAMY,WAAY,CAChC,IAAMA,GAAc5D,KAAKgD,MAAMY,WAC/B5D,KAAKoE,SAAS,CAACR,aAAYJ,gBAAgB,IAC3CxD,KAAK0C,kB,uBAKT,WACE,IAAK1C,KAAKgD,MAAMS,UAAW,CACzB,IADyB,EACnBiB,EAAU1E,KAAKgD,MAAMjC,KAAK+D,QADP,cAEPJ,GAFO,IAEzB,2BAA2B,CAAC,IAAD,EAAhBjE,EAAgB,sBACNA,GADM,IACzB,2BAAwB,CAAC,IAAda,EAAa,QAClBsD,EAAgBJ,SAASC,eAAT,eACVnD,EAAKb,IADK,YACEa,EAAKpB,MACzBU,UAEkB,oBAAlBgE,GACkB,qBAAlBA,GACkB,mBAAlBA,IAEAJ,SAASC,eAAT,eAAgCnD,EAAKb,IAArC,YAA4Ca,EAAKpB,MAAOU,UACtD,OACFU,EAAKS,WAAY,EACjBT,EAAKH,SAAWW,IAChBR,EAAKkB,UAAYa,KAAKC,IAAItD,KAAKgD,MAAMG,UAAY7B,EAAKb,KAAO4C,KAAKC,IAAItD,KAAKgD,MAAMI,UAAY9B,EAAKpB,MAE9E,qBAAlB0E,IACFtD,EAAKS,WAAY,EACjBT,EAAKH,SAAWW,IAChBR,EAAKkB,UAAY,GAEG,oBAAlBoC,IACFtD,EAAKS,WAAY,EACjBT,EAAKH,SAAWW,IAChBR,EAAKkB,UAAYa,KAAKC,IAAItD,KAAKgD,MAAMG,UAAY7B,EAAKb,KAAO4C,KAAKC,IAAItD,KAAKgD,MAAMI,UAAY9B,EAAKpB,KAClGoB,EAAKlB,SAAU,EACfkB,EAAKjB,QAAS,EACdiB,EAAKgB,aAAe,KACpBhB,EAAKiC,QAAS,IA5BO,gCAFF,kC,wBAqC7B,WACE,IAAKvD,KAAKgD,MAAMS,UAAW,CACzB,IADyB,EACnBiB,EAAU1E,KAAKgD,MAAMjC,KAAK+D,QADP,cAEPJ,GAFO,IAEzB,2BAA2B,CAAC,IAAD,EAAhBjE,EAAgB,sBACNA,GADM,IACzB,2BAAwB,CAAC,IAAda,EAAa,QAIA,mBAHFkD,SAASC,eAAT,eACVnD,EAAKb,IADK,YACEa,EAAKpB,MACzBU,YAEA4D,SAASC,eAAT,eAAgCnD,EAAKb,IAArC,YAA4Ca,EAAKpB,MAAOU,UACtD,OACFU,EAAKjB,QAAS,IARO,gCAFF,kC,uBAmB7B,SAAU0E,GACR,IAAK/E,KAAKgD,MAAMS,UAAW,CACzBzD,KAAKqE,YACLrE,KAAKmE,kBACL,IAKIjD,EALGH,EAAQf,KAAKgD,MAAbjC,KACDC,EACJD,EAAKf,KAAKgD,MAAMC,UAAUjD,KAAKgD,MAAME,UACjCjC,EACJF,EAAKf,KAAKgD,MAAMG,WAAWnD,KAAKgD,MAAMI,WAExC,OAAQ2B,GACN,IAAK,WACH7D,EAAWJ,EAASC,EAAMC,EAAWC,GACrC,MACF,IAAK,QACHC,EAAWqB,EAAMxB,EAAMC,EAAWC,GAClC,MACF,IAAK,MACHC,EDlUH,SAAaH,EAAMC,EAAWC,GACjC,IAAM+D,EAAI,GACJ9D,EAAW,GAEjB,IADA8D,EAAEzD,KAAKP,GACY,IAAbgE,EAAEvD,QAAa,CAEjB,IAAIH,EAAO0D,EAAEnD,QACb,GAAGP,IAASL,EAAY,OAAOC,EAC/BI,EAAKS,WAAY,EACjBb,EAASK,KAAKD,GACd,IANiB,EAMXY,EAAYG,EAAYf,EAAMP,GANnB,cAOEmB,GAPF,IAOjB,IAAI,EAAJ,qBAA6B,CAAC,IAApBb,EAAmB,QACzB2D,EAAEzD,KAAKF,GAQPA,EAAMiB,aAAehB,GAhBR,+BAoBrB,OAAOJ,EC0SU+D,CAAIlE,EAAMC,EAAWC,GAChC,MACF,IAAK,MACHC,EFjUH,SAAaH,EAAMC,EAAWC,GACjC,IAAMiE,EAAQ,GACRhE,EAAW,GAEjB,IADAgE,EAAM3D,KAAKP,GACY,IAAjBkE,EAAMzD,QAAa,CACrB,IAAIH,EAAO4D,EAAMA,EAAMzD,OAAS,GAIhC,GADAyD,EAAMC,QAAQ,EAAG,IACd7D,EAAKS,UAAR,CACAT,EAAKS,WAAY,EACjBb,EAASK,KAAKD,GACd,IAAMY,EAAYG,EAAYf,EAAMP,GACpC,GAAGO,IAASL,EAAY,OAAOC,EAC/BA,EAASK,KAAKD,GAVO,oBAWFY,GAXE,IAWrB,IAAI,EAAJ,qBAA6B,CAAC,IAApBb,EAAmB,QACzB6D,EAAM3D,KAAKF,GACXA,EAAMiB,aAAehB,GAbJ,iCE6TR8D,CAAIrE,EAAMC,EAAWC,GAKpC,IAAMoE,EAuKZ,SAA+BpE,GAM7B,IAAMoE,EAAe,GACjBC,EAAOrE,EAEX,KAAgB,OAATqE,GACLD,EAAaE,QAAQD,GACrBA,EAAOA,EAAKhD,aAEd,OAAO+C,EApLkBG,CAAsBvE,GAC3CoE,EAAa9D,KAAK,OAClBvB,KAAKyF,QAAQvE,EAAUmE,EAAcN,M,qBAIzC,SAAQ7D,EAAUmE,EAAcN,GAAO,IAAD,OAChCW,EAAQ,GACA,QAATX,IAAgBW,EAAQ,IAK3B,IAPoC,eAO3BC,GACP,GAAIA,IAAMzE,EAASO,OAIjB,OAHAmE,YAAW,WACT,EAAKC,uBAAuBR,KAC3BK,EAAQC,GACL,CAAN,UAEFC,YAAW,WACT,IAAMtE,EAAOJ,EAASyE,GAChBf,EAAgBJ,SAASC,eAAT,eACZnD,EAAKb,IADO,YACAa,EAAKpB,MACzBU,UAEkB,oBAAlBgE,GACkB,qBAAlBA,IAEAJ,SAASC,eAAT,eAAgCnD,EAAKb,IAArC,YAA4Ca,EAAKpB,MAAOU,UACtD,uBAEH8E,EAAQC,IAnBJA,EAAI,EAAGA,GAAKzE,EAASO,OAAQkE,IAAK,CAAC,IAAD,IAAlCA,GAAkC,qC,oCAuB7C,SAAuBN,GAErB,IAFoC,IAAD,kBAE1BM,GACiB,QAApBN,EAAaM,GACfC,YAAW,WACT,EAAKzB,oBACA,GAAJwB,GAEHC,YAAW,WACT,IAAMtE,EAAO+D,EAAaM,GACpBf,EAAgBJ,SAASC,eAAT,eACZnD,EAAKb,IADO,YACAa,EAAKpB,MACzBU,UAEkB,oBAAlBgE,GACkB,qBAAlBA,IAEAJ,SAASC,eAAT,eAAgCnD,EAAKb,IAArC,YAA4Ca,EAAKpB,MAAOU,UACtD,6BAEC,GAAJ+E,IAlBEA,EAAI,EAAGA,EAAIN,EAAa5D,OAAQkE,IAAM,EAAtCA,K,oBAuBX,WAAU,IAAD,OACP,EAA+B3F,KAAKgD,MAA7BjC,EAAP,EAAOA,KAAMyC,EAAb,EAAaA,eACb,OACE,gCACE,qBAAK5C,UAAW,eAAhB,SACE,6CAEF,wBACEkF,KAAK,SACLlF,UAAY,WACZmF,QAAS,kBAAM,EAAKC,UAAU,aAHhC,wBAMA,wBACEF,KAAK,SACLlF,UAAY,WACZmF,QAAS,kBAAM,EAAKC,UAAU,UAHhC,gBAMA,wBACEF,KAAK,SACLlF,UAAY,2BACZmF,QAAS,kBAAM,EAAKC,UAAU,QAHhC,kCAMA,wBACEF,KAAK,SACLlF,UAAY,WACZmF,QAAS,kBAAM,EAAKC,UAAU,QAHhC,gCAMA,uBACEpF,UAAU,iBACVqF,aAAc,kBAAM,EAAK/B,oBAF3B,SAGE,uBAAOtD,UAAU,OAAjB,SACGG,EAAKmF,KAAI,SAACzF,EAAK0F,GACd,OACE,6BACG1F,EAAIyF,KAAI,SAAC5E,EAAM8E,GACd,IAAO3F,EAAuCa,EAAvCb,IAAKP,EAAkCoB,EAAlCpB,IAAKC,EAA6BmB,EAA7BnB,SAAUC,EAAmBkB,EAAnBlB,QAASC,EAAUiB,EAAVjB,OACpC,OACE,cAAC,EAAD,CAEEH,IAAKA,EACLC,SAAUA,EACVC,QAASA,EACTC,OAAQA,EACRmD,eAAgBA,EAChBlD,YAAa,SAACG,EAAKP,GAAN,OAAc,EAAK8D,gBAAgBvD,EAAKP,IACrDK,aAAc,SAACE,EAAKP,GAAN,OAAc,EAAKmG,iBAAiB5F,EAAKP,IACvDM,UAAW,kBAAM,EAAK8F,cAAc7F,EAAKP,IACzCO,IAAKA,GATA2F,OALJD,UAsBjB,wBACEL,KAAK,SACLlF,UAAU,iBACVmF,QAAS,kBAAM,EAAK1B,aAHtB,4BAMA,wBACEyB,KAAK,SACLlF,UAAU,kBACVmF,QAAS,kBAAM,EAAKzB,cAHtB,6BAMCtE,KAAKgD,MAAMe,QACV,wBACE+B,KAAK,SACLlF,UAAU,WACVmF,QAAS,kBAAM,EAAKQ,cAHtB,6BAOA,wBACET,KAAK,SACLlF,UAAY,WACZmF,QAAS,kBAAM,EAAKQ,cAHtB,wC,GAvcyC1F,aAmd7C8D,EAAc,SAAC5D,EAAMN,EAAKP,GAE9B,IAAMwE,EAAU3D,EAAK+D,QACfxD,EAAOoD,EAAQjE,GAAKP,GAC1B,IAAKoB,EAAKlB,UAAYkB,EAAKnB,UAAYmB,EAAKiC,OAAQ,CAClD,IAAMiD,EAAO,2BACRlF,GADQ,IAEXjB,QAASiB,EAAKjB,SAEhBqE,EAAQjE,GAAKP,GAAOsG,EAEtB,OAAO9B,G,MCneM+B,MARf,WACE,OACE,qBAAK7F,UAAU,MAAf,SACC,cAAC,EAAD,OCKU8F,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEF7C,SAASC,eAAe,SAM1BiC,M","file":"static/js/main.65c16448.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n  }\r\n}","/*\r\nThis is the lazy implementation of djikstra. You could achieve far better \r\ntime complexity with using a Adjacency List representation of the graph\r\n(doesn't really apply in this case) and a min heap instead of sorting.\r\n*/\r\n/*\r\nDjikstra's algorithm is a single source shortest path algorithm.\r\n*/\r\nexport function djikstra(grid, startNode, finishNode) {\r\n    const openList = [];\r\n    startNode.distance = 0;\r\n    //same as having access to distance array, with all the distance[node]\r\n    //set to infinity, except that of startNode i.e. distance[startNode] = 0.\r\n    const closedList = getDistanceArray(grid);\r\n  \r\n    while (closedList.length) {\r\n      closedList.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n      const node = closedList.shift();\r\n        /*the next statement is necessary because if unvisitedNeighbors is not able\r\n        to pick any node because of the wall, it will pick one with the \r\n        infinite distance and start from there.\r\n        */\r\n        if (node.distance === Infinity) return openList;\r\n        node.isVisited = true;\r\n        openList.push(node);\r\n        if (node === finishNode) return openList;\r\n        relaxTheNodes(node, grid);\r\n    }\r\n  }\r\n  \r\n  function getDistanceArray(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  function relaxTheNodes(node, grid) {\r\n    //gives the 4-direction neighbors except the ones which are visited\r\n    //or are walls.\r\n    const unvisitedNeighbors = toBeVisited(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n  \r\n  function toBeVisited(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    //filter all the nodes which are already visited or are walls \r\n    //as defined by the isVisited and isWall property of the node.\r\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\r\n  }\r\n   ","/*\r\nRefer https://www.geeksforgeeks.org/a-search-algorithm/ for the \r\nimplementation idea and the algorithm.\r\n*/\r\n/*\r\nThis is almost same as Djikstra except for the fact that we add heuristic\r\n(the manhattan distance of the node to the finishNode) to the \r\ndistance property.\r\n*/\r\n/* This is a very lazy way to implement A*, which I had to resort to \r\ndue to time crunch. The ideal way should be that the animation should be \r\nable to show the \"use of brain\" by A* i.e the rejection of paths.\r\n*/\r\nexport function AStar(grid, startNode, finishNode) {\r\n    const openList = [];\r\n    startNode.distance = 0;\r\n    //same as having access to distance array, with all the distance[node]\r\n    //set to infinity, except that of startNode i.e. distance[startNode] = 0.\r\n    const closedList = getDistanceArray(grid);\r\n  \r\n    while (closedList.length) {\r\n      closedList.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n      const node = closedList.shift();\r\n      /*the next statement is necessary because if unvisitedNeighbors is not able\r\n      to pick any node because of the wall, it will pick one with the \r\n      infinite distance and start from there.\r\n      */\r\n        if (node.distance === Infinity) return openList;\r\n        node.isVisited = true;\r\n        openList.push(node);\r\n        if (node === finishNode) return openList;\r\n        relaxTheNodes(node, grid);\r\n    }\r\n  }\r\n  \r\n  function getDistanceArray(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  function relaxTheNodes(node, grid) {\r\n    const unvisitedNeighbors = toBeVisited(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.distance = node.distance + 1 + neighbor.heuristic;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n  \r\n  function toBeVisited(node, grid) {\r\n    //gives the 4-direction neighbors except the ones which are visited\r\n    //or are walls.\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    //filter all the nodes which are already visited or are walls \r\n    //as defined by the isVisited and isWall property of the node.\r\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\r\n  }\r\n\r\n","/*\r\nThis is a iterative version of dfs search using an array which\r\nsimulates a stack. In Java, you would explicitly use a stack.\r\nAnother popular way of implementing a dfs search is the recursive search.\r\nDFS will not give the shortest path, rather, a path.\r\n*/\r\nexport function DFS(grid, startNode, finishNode){\r\n    const stack = [] ;\r\n    const openList = [] ;\r\n    stack.push(startNode) ;\r\n    while(stack.length !== 0){\r\n        let node = stack[stack.length - 1] ;\r\n        //gives the last element of the stack array.\r\n        //Or rather, the top of the stack.\r\n        stack.splice(-1, 1) ;\r\n        if(node.isVisited) continue ;\r\n        node.isVisited = true ;\r\n        openList.push(node) ;\r\n        const neighbors = toBeVisited(node, grid) ;\r\n        if(node === finishNode) return openList ;\r\n        openList.push(node) ;\r\n        for(const nodes of neighbors){\r\n            stack.push(nodes) ;\r\n            nodes.previousNode = node ;\r\n        }\r\n    }\r\n}\r\nfunction toBeVisited(node, grid){\r\n    //gives the 4-direction neighbors except the ones which are visited\r\n    //or are walls.\r\n    const neighbors = [] ;\r\n    const {row, col} = node ;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    //filter all the nodes which are already visited or are walls \r\n    //as defined by the isVisited and isWall property of the node.\r\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\r\n}","//Level order traversal using a queue. \r\n//You process a node and then add all the connected nodes to the queue.\r\nexport function BFS(grid, startNode, finishNode){\r\n    const q = [] ;\r\n    const openList = [] ;\r\n    q.push(startNode) ;\r\n    while(q.length !== 0){\r\n        //To obtain the first element that entered the queue.\r\n        let node = q.shift() ;\r\n        if(node === finishNode) return openList ;\r\n        node.isVisited = true ;\r\n        openList.push(node) ;\r\n        const neighbors = toBeVisited(node, grid) ;\r\n        for(const nodes of neighbors){\r\n            q.push(nodes) ;\r\n            /*\r\n             the mistake I was making earlier, \r\n            when I was not able to get the animation for the shortest\r\n            path, was that I was not changing the previousNode property \r\n            of the node. Look at the function getNodesInShortestPathOrder(),\r\n            in the PathfindingVisualizer.jsx for reference.\r\n             */\r\n            nodes.previousNode = node ;\r\n            \r\n        }\r\n    }\r\n    return openList ;\r\n}\r\nfunction toBeVisited(node, grid){\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  //filter all the nodes which are already visited or are walls \r\n  //as defined by the isVisited and isWall property of the node.\r\n  return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\r\n}\r\n  ","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {djikstra} from '../algorithms/djikstra';\r\nimport {AStar} from '../algorithms/AStar';\r\nimport {DFS} from '../algorithms/DFS';\r\nimport {BFS} from '../algorithms/BFS';\r\n\r\nimport './PathfindingVisualizer.css';\r\n/*\r\nThere is a minor error with the app. When you set up walls around the start point such \r\nthat there is no path to the target, it gives the correct result, showing no path to it.\r\nNow if you breakdown the wall at one point such that the target is reachable now, \r\nit shows the path. The error occurs when you once again set up the wall around it.\r\nFor some reason it remembers the path it took in the previous step, and shows the path, \r\neven though there isn't one.\r\nThe only way around this problem is to refresh the page and start over again.\r\n*/\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super() ;\r\n    this.state = {\r\n      grid: [],\r\n      startRow: 5,\r\n      finishRow: 5,\r\n      startCol: 5,\r\n      finishCol: 15,\r\n      mouseIsPressed: false,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false,\r\n      currRow: 0,\r\n      currCol: 0,\r\n      desktop: true,\r\n    };\r\n\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.setUpTheGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  toggleIsRunning() {\r\n    this.setState({isRunning: !this.state.isRunning});\r\n  }\r\n///changeView() is used to switch from desktop to mobile view and vice versa.\r\n//is called when you click on Using a Mobile button.\r\n  changeView() {\r\n    if (!this.state.isRunning) {\r\n      this.clearGrid();\r\n      this.clearWalls();\r\n      const desktop = !this.state.desktop;\r\n      let grid;\r\n      if (desktop) {\r\n        grid = this.setUpTheGrid(20, 35) ;\r\n        this.setState({desktop, grid});\r\n      } else {\r\n        //The initial start and finish nodes change to [0, 0] and [0, 5]\r\n        //when switching to mobile view if \r\n        //they exist outside the 10*20 grid(i.e. the mobile view grid).\r\n        if (this.state.startRow > 10 || this.state.finishRow > 20 || this.state.startCol > 10 || this.state.finishCol > 20)\r\n        {\r\n          this.state.startCol = 0 ;\r\n          this.state.startRow = 0 ;\r\n          this.state.finishCol = 5 ;\r\n          this.state.finishRow = 0 ;\r\n        }\r\n          grid = this.setUpTheGrid(10, 20) ;\r\n          this.setState({desktop, grid});\r\n      }\r\n    }\r\n  }\r\n//we will be using 20*35 grid for desktop view and\r\n//10*20 grid for the mobile view\r\n  setUpTheGrid = (rowCount = 20, colCount = 35) => {\r\n    const initialGrid = [];\r\n    for (let row = 0; row < rowCount; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < colCount; col++) {\r\n        currentRow.push(this.setUpTheNodes(row, col));\r\n      }\r\n      initialGrid.push(currentRow);\r\n    }\r\n    return initialGrid;\r\n  };\r\n//Creates the individual node objects with various properties.\r\n  setUpTheNodes = (row, col) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart: row === this.state.startRow && col === this.state.startCol,\r\n      isFinish: row === this.state.finishRow && col === this.state.finishCol,\r\n        //The initial distance is set to infinity for every node.\r\n      distance: Infinity,\r\n      /*\r\n      The heuristic property used here will be used for the A* search.\r\n      This heuristic property is an approximate heuristic and is the \r\n      Manhattan Distance between the node and target.\r\n      */\r\n      heuristic: Math.abs(this.state.finishRow - row) + Math.abs(this.state.finishCol - col),\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isNode: true,\r\n    };\r\n  };\r\n\r\n  handleMouseDown(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.isGridClear()) {\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-start'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isStartNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-finish'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isFinishNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else {\r\n          const newGrid = toggleWalls(this.state.grid, row, col);\r\n          this.setState({\r\n            grid: newGrid,\r\n            mouseIsPressed: true,\r\n            isWallNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n            //change if needed\r\n          });\r\n        }\r\n      } else {\r\n        this.clearGrid();\r\n      }\r\n    }\r\n  }\r\n // isGridClear() method used by handleMouseDown()\r\n  isGridClear() {\r\n    for (const row of this.state.grid) {\r\n      for (const node of row) {\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName === 'node node-visited' ||\r\n          nodeClassName === 'node node-shortest-path'\r\n        ) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.state.mouseIsPressed) {\r\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n          .className;\r\n        if (this.state.isStartNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevStartNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevStartNode.isStart = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currStartNode = this.state.grid[row][col];\r\n            currStartNode.isStart = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-start';\r\n          }\r\n          this.setState({startRow: row, startCol: col});\r\n        } else if (this.state.isFinishNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevFinishNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevFinishNode.isFinish = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currFinishNode = this.state.grid[row][col];\r\n            currFinishNode.isFinish = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-finish';\r\n          }\r\n          this.setState({finishRow: row, finishCol: col});\r\n        } else if (this.state.isWallNode) {\r\n          const newGrid = toggleWalls(this.state.grid, row, col);\r\n          this.setState({grid: newGrid});\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    if (!this.state.isRunning) {\r\n      this.setState({mouseIsPressed: false});\r\n      if (this.state.isStartNode) {\r\n        const isStartNode = !this.state.isStartNode;\r\n        this.setState({isStartNode, startRow: row, startCoL: col});\r\n      } else if (this.state.isFinishNode) {\r\n        const isFinishNode = !this.state.isFinishNode;\r\n        this.setState({\r\n          isFinishNode,\r\n          finishRow: row,\r\n          finishCol: col,\r\n        });\r\n      }\r\n      this.setUpTheGrid();\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.state.isStartNode) {\r\n      const isStartNode = !this.state.isStartNode;\r\n      this.setState({isStartNode, mouseIsPressed: false});\r\n    } else if (this.state.isFinishNode) {\r\n      const isFinishNode = !this.state.isFinishNode;\r\n      this.setState({isFinishNode, mouseIsPressed: false});\r\n    } else if (this.state.isWallNode) {\r\n      const isWallNode = !this.state.isWallNode;\r\n      this.setState({isWallNode, mouseIsPressed: false});\r\n      this.setUpTheGrid();\r\n    }\r\n  }\r\n\r\n\r\n  clearGrid() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish' &&\r\n            nodeClassName !== 'node node-wall'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.heuristic = Math.abs(this.state.finishRow - node.row) + Math.abs(this.state.finishCol - node.col);\r\n          }\r\n          if (nodeClassName === 'node node-finish') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.heuristic = 0;\r\n          }\r\n          if (nodeClassName === 'node node-start') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.heuristic = Math.abs(this.state.finishRow - node.row) + Math.abs(this.state.finishCol - node.col);\r\n            node.isStart = true;\r\n            node.isWall = false;\r\n            node.previousNode = null;\r\n            node.isNode = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clearWalls() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (nodeClassName === 'node node-wall') {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isWall = false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n/*\r\nFor this function, onClick() sends different switch cases as a string\r\n*/\r\n  visualize(algo) {\r\n    if (!this.state.isRunning) {\r\n      this.clearGrid();\r\n      this.toggleIsRunning();\r\n      const {grid} = this.state;\r\n      const startNode =\r\n        grid[this.state.startRow][this.state.startCol];\r\n      const finishNode =\r\n        grid[this.state.finishRow][this.state.finishCol];\r\n      let openList;\r\n      switch (algo) {\r\n        case 'Djikstra':\r\n          openList = djikstra(grid, startNode, finishNode);\r\n          break;\r\n        case 'AStar':\r\n          openList = AStar(grid, startNode, finishNode);\r\n          break;\r\n        case 'BFS':\r\n          openList = BFS(grid, startNode, finishNode);\r\n          break;\r\n        case 'DFS':\r\n          openList = DFS(grid, startNode, finishNode);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n      const pathToTarget = getThePathToTheTarget(finishNode) ;\r\n      pathToTarget.push('end') ;\r\n      this.animate(openList, pathToTarget, algo) ;\r\n  }\r\n}\r\n//openList is the array returned by the algorithms.\r\n  animate(openList, pathToTarget, algo) {\r\n    let DELAY = 10 ;\r\n    if(algo === 'BFS') DELAY = 0.1 ;\r\n    /* delay reduced for bfs to better show how bfs \r\n    processes all the nodes in its path, and also if the nodes are far apart for \r\n    bfs, it takes a lot of time which makes the app seem like it is malfunctioning.\r\n    */\r\n    for (let i = 0; i <= openList.length; i++) {\r\n      if (i === openList.length) {\r\n        setTimeout(() => {\r\n          this.animatePathToTheTarget(pathToTarget);\r\n        }, DELAY * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = openList[i];\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish'\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-visited';\r\n        }\r\n      }, DELAY * i);\r\n    }\r\n  }\r\n\r\n  animatePathToTheTarget(pathToTarget) {\r\n    //The shortest path is calculated using the previousNode property of the node.\r\n    for (let i = 0; i < pathToTarget.length; i++) {\r\n      if (pathToTarget[i] === 'end') {\r\n        setTimeout(() => {\r\n          this.toggleIsRunning();\r\n        }, i * 50);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = pathToTarget[i];\r\n          const nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-shortest-path';\r\n          }\r\n        }, i * 40);\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state;\r\n    return (\r\n      <div>\r\n        <div className =\"project_Name\">\r\n          <p>PATHFINDER</p>\r\n        </div>\r\n        <button\r\n          type=\"button\"\r\n          className = \"button_2\"\r\n          onClick={() => this.visualize('Djikstra')}>\r\n          Djikstra's\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className = \"button_2\"\r\n          onClick={() => this.visualize('AStar')}>\r\n          A*\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className = \"button_2 btn btn-primary\"\r\n          onClick={() => this.visualize('BFS')}>\r\n          Breadth First Search\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className = \"button_2\"\r\n          onClick={() => this.visualize('DFS')}>\r\n          Depth First Search\r\n        </button>\r\n        <table\r\n          className=\"grid-container\"\r\n          onMouseLeave={() => this.handleMouseLeave()}>\r\n          <tbody className=\"grid\">\r\n            {grid.map((row, rowId) => {\r\n              return (\r\n                <tr key={rowId}>\r\n                  {row.map((node, nodeId) => {\r\n                    const {row, col, isFinish, isStart, isWall} = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeId}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                        onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                        onMouseUp={() => this.handleMouseUp(row, col)}\r\n                        row={row}></Node>\r\n                    );\r\n                  })}\r\n                </tr>\r\n              );\r\n            })}\r\n          </tbody>\r\n        </table>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-danger\"\r\n          onClick={() => this.clearGrid()}>\r\n          Reset the Maze\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-warning\"\r\n          onClick={() => this.clearWalls()}>\r\n          Break the walls\r\n        </button>\r\n        {this.state.desktop ? (\r\n          <button\r\n            type=\"button\"\r\n            className=\"button_1\"\r\n            onClick={() => this.changeView()}>\r\n            Using A Mobile?\r\n          </button>\r\n        ) : (\r\n          <button\r\n            type=\"button\"\r\n            className = \"button_1\"\r\n            onClick={() => this.changeView()}>\r\n            Want A Bigger View?\r\n          </button>\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst toggleWalls = (grid, row, col) => {\r\n  //change the isWall property of the node and vice versa.\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  if (!node.isStart && !node.isFinish && node.isNode) {\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\n//Returns the shortest path in case of bfs, djikstra and A* \r\n//Returns a random path in case of dfs.\r\nfunction getThePathToTheTarget(finishNode) {\r\n  /*\r\n  Calling the algorithms sets the previousNode property of the nodes to the target.\r\n  We calculate the shortest path by starting with finishNode and going back to \r\n  the startNode.\r\n   */\r\n  const pathToTarget = [];\r\n  let curr = finishNode;\r\n  //stop when you reach the startNode, whose previousNode = null.\r\n  while (curr !== null) {\r\n    pathToTarget.unshift(curr);\r\n    curr = curr.previousNode;\r\n  }\r\n  return pathToTarget;\r\n}","import React from 'react';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n     <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}